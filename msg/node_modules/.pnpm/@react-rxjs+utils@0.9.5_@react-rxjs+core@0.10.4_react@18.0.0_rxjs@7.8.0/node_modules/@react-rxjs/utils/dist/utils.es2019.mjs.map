{
  "version": 3,
  "sources": ["../src/combineKeys.ts", "../src/createSignal.ts", "../src/createKeyedSignal.ts", "../src/mergeWithKey.ts", "../src/partitionByKey.ts", "../src/suspend.ts", "../src/internal-utils.ts", "../src/suspended.ts", "../src/switchMapSuspended.ts", "../src/selfDependant.ts", "../src/contextBinder.ts", "../src/createListener.ts"],
  "sourcesContent": ["import { Observable, Subscription } from \"rxjs\"\n\nexport interface MapWithChanges<K, V> extends Map<K, V> {\n  changes: Set<K>\n}\n\n/**\n * Creates a stream that combines the result of the streams from each key of the input stream.\n *\n * @param keys$ Stream of the list of keys to subscribe to.\n * @param getInner$ Function that returns the stream for each key.\n * @returns An stream with a map containing the latest value from the stream of each key.\n */\nexport const combineKeys = <K, T>(\n  keys$: Observable<Array<K> | Set<K>>,\n  getInner$: (key: K) => Observable<T>,\n): Observable<MapWithChanges<K, T>> =>\n  new Observable((observer) => {\n    const innerSubscriptions = new Map<K, Subscription>()\n    let changes = new Set<K>()\n    const currentValue = new Map<K, T>()\n    let updatingSource = false\n    let isPristine = true\n\n    const next = () => {\n      if (!updatingSource) {\n        const result = Object.assign(new Map(currentValue), {\n          changes,\n        })\n        changes = new Set<K>()\n        isPristine = false\n        observer.next(result)\n      }\n    }\n\n    const subscription = keys$.subscribe(\n      (nextKeysArr) => {\n        updatingSource = true\n        const nextKeys = new Set(nextKeysArr)\n        innerSubscriptions.forEach((sub, key) => {\n          if (!nextKeys.has(key)) {\n            sub.unsubscribe()\n            innerSubscriptions.delete(key)\n            if (currentValue.has(key)) {\n              changes.add(key)\n              currentValue.delete(key)\n            }\n          } else {\n            nextKeys.delete(key)\n          }\n        })\n        nextKeys.forEach((key) => {\n          innerSubscriptions.set(\n            key,\n            getInner$(key).subscribe(\n              (x) => {\n                if (!currentValue.has(key) || currentValue.get(key) !== x) {\n                  changes.add(key)\n                  currentValue.set(key, x)\n                  next()\n                }\n              },\n              (e) => {\n                observer.error(e)\n              },\n            ),\n          )\n        })\n        updatingSource = false\n        // If there are no changes but the nextKeys are an empty iterator\n        // and we have never emitted before, that means that the first\n        // value that keys$ has emitted is an empty iterator, therefore\n        // we should emit an empy Map\n        if (changes.size || (isPristine && !nextKeys.size)) next()\n      },\n      (e) => {\n        observer.error(e)\n      },\n      () => {\n        observer.complete()\n      },\n    )\n\n    return () => {\n      subscription.unsubscribe()\n      innerSubscriptions.forEach((sub) => {\n        sub.unsubscribe()\n      })\n    }\n  })\n", "import { identity, Observable, Subject } from \"rxjs\"\n\n/**\n * Creates a signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @param mapper a mapper function, for mapping the arguments of the emitter function into\n * the value of the Observable.\n * @returns [1, 2]\n * 1. The Observable<T>\n * 2. The emitter function.\n */\nexport function createSignal<A extends unknown[], T>(\n  mapper: (...args: A) => T,\n): [Observable<T>, (...args: A) => void]\n\n/**\n * Creates a void signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable<void>\n * 2. The emitter function.\n */\nexport function createSignal(): [Observable<void>, () => void]\n\n/**\n * Creates a signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable<T>\n * 2. The emitter function.\n */\nexport function createSignal<T>(): [Observable<T>, (payload: T) => void]\n\nexport function createSignal<A extends unknown[], T>(\n  mapper: (...args: A) => T = identity as any,\n): [Observable<T>, (...args: A) => void] {\n  const subject = new Subject<T>()\n  return [subject.asObservable(), (...args: A) => subject.next(mapper(...args))]\n}\n", "import { GroupedObservable, Observable, Observer } from \"rxjs\"\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<T, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<T>(): [\n  (key: T) => GroupedObservable<T, T>,\n  (key: T) => void,\n]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<K, T>(): [\n  (key: K) => GroupedObservable<K, T>,\n  (key: K, value: T) => void,\n]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function.\n */\nexport function createKeyedSignal<K, T>(\n  keySelector: (signal: T) => K,\n): [(key: K) => GroupedObservable<K, T>, (signal: T) => void]\n\n/**\n * Creates a \"keyed\" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.\n *\n * @param keySelector a function that extracts the key from the emitted value\n * @param mapper a function that maps the arguments of the emitter function to the value of the GroupedObservable\n * @returns [1, 2]\n * 1. The getter function that returns the GroupedObservable<K, T>\n * 2. The emitter function (...args: any[]) => T.\n */\nexport function createKeyedSignal<K, T, A extends any[]>(\n  keySelector: (signal: T) => K,\n  mapper: (...args: A) => T,\n): [(key: K) => GroupedObservable<K, T>, (...args: A) => void]\n\nexport function createKeyedSignal<K, T, A extends any[]>(\n  keySelector?: (signal: T) => K,\n  mapper?: (...args: A) => T,\n): [(key: K) => GroupedObservable<K, T>, (...args: A) => void] {\n  const observersMap = new Map<K, Set<Observer<T>>>()\n\n  return [\n    (key: K) => {\n      const res = new Observable<T>((observer) => {\n        if (!observersMap.has(key)) {\n          observersMap.set(key, new Set())\n        }\n        const set = observersMap.get(key)!\n        set.add(observer)\n        return () => {\n          set.delete(observer)\n          if (set.size === 0) {\n            observersMap.delete(key)\n          }\n        }\n      }) as GroupedObservable<K, T>\n      ;(res as any).key = key\n      return res\n    },\n    (...args: A) => {\n      const payload = mapper\n        ? mapper(...args)\n        : args.length === 2\n        ? args[1]\n        : args[0]\n      const key = keySelector ? keySelector(payload) : args[0]\n      observersMap.get(key)?.forEach((o) => {\n        o.next(payload)\n      })\n    },\n  ]\n}\n", "import { merge, Observable, ObservableInput, from, SchedulerLike } from \"rxjs\"\nimport { map } from \"rxjs/operators\"\n\n/**\n * Emits the values from all the streams of the provided object, in a result\n * which provides the key of the stream of that emission.\n *\n * @param input object of streams\n */\nexport const mergeWithKey: <\n  O extends { [P in keyof any]: ObservableInput<any> },\n  OT extends {\n    [K in keyof O]: O[K] extends ObservableInput<infer V>\n      ? { type: K; payload: V }\n      : unknown\n  },\n>(\n  x: O,\n  concurrent?: number,\n  scheduler?: SchedulerLike,\n) => Observable<OT[keyof O]> = (input, ...optionalArgs) =>\n  merge<any[]>(\n    ...(Object.entries(input)\n      .map(\n        ([type, stream]) =>\n          from(stream).pipe(\n            map((payload) => ({ type, payload } as any)),\n          ) as any,\n      )\n      .concat(optionalArgs) as any[]),\n  )\n", "import { shareLatest } from \"@react-rxjs/core\"\nimport {\n  GroupedObservable,\n  noop,\n  Observable,\n  Subject,\n  Subscription,\n  identity,\n} from \"rxjs\"\nimport { map } from \"rxjs/operators\"\n\n/**\n * Groups the elements from the source stream by using `keySelector`, returning\n * a stream of the active keys, and a function to get the stream of a specific group\n *\n * @param stream Input stream\n * @param keySelector Function that specifies the key for each element in `stream`\n * @param streamSelector Function to apply to each resulting group\n * @returns [1, 2]\n * 1. A function that accepts a key and returns the stream for the group of that key.\n * 2. A stream with the list of active keys\n */\nexport function partitionByKey<T, K, R>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n  streamSelector: (grouped: Observable<T>, key: K) => Observable<R>,\n): [(key: K) => GroupedObservable<K, R>, Observable<K[]>]\n\n/**\n * Groups the elements from the source stream by using `keySelector`, returning\n * a stream of the active keys, and a function to get the stream of a specific group\n *\n * @param stream Input stream\n * @param keySelector Function that specifies the key for each element in `stream`\n * @returns [1, 2]\n * 1. A function that accepts a key and returns the stream for the group of that key.\n * 2. A stream with the list of active keys\n */\nexport function partitionByKey<T, K>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n): [(key: K) => GroupedObservable<K, T>, Observable<K[]>]\n\nexport function partitionByKey<T, K, R>(\n  stream: Observable<T>,\n  keySelector: (value: T) => K,\n  streamSelector?: (grouped: Observable<T>, key: K) => Observable<R>,\n): [(key: K) => GroupedObservable<K, R>, Observable<K[]>] {\n  const groupedObservables$ = new Observable<Map<K, GroupedObservable<K, R>>>(\n    (subscriber) => {\n      const groups: Map<K, InnerGroup<T, K, R>> = new Map()\n\n      let emitted = false\n      let sourceCompleted = false\n      const sub = stream.subscribe(\n        (x) => {\n          const key = keySelector(x)\n          if (groups.has(key)) {\n            return groups.get(key)!.source.next(x)\n          }\n\n          const subject = new Subject<T>()\n\n          const res = shareLatest()(\n            (streamSelector || identity)(subject, key),\n          ) as GroupedObservable<K, R>\n          ;(res as any).key = key\n\n          const innerGroup: InnerGroup<T, K, R> = {\n            source: subject,\n            observable: res,\n            subscription: new Subscription(),\n          }\n          groups.set(key, innerGroup)\n\n          innerGroup.subscription = res.subscribe(\n            noop,\n            (e) => subscriber.error(e),\n            () => {\n              groups.delete(key)\n              subscriber.next(mapGroups(groups))\n\n              if (groups.size === 0 && sourceCompleted) {\n                subscriber.complete()\n              }\n            },\n          )\n\n          subject.next(x)\n          subscriber.next(mapGroups(groups))\n          emitted = true\n        },\n        (e) => {\n          sourceCompleted = true\n          if (groups.size) {\n            groups.forEach((g) => g.source.error(e))\n          } else {\n            subscriber.error(e)\n          }\n        },\n        () => {\n          sourceCompleted = true\n          if (groups.size) {\n            groups.forEach((g) => g.source.complete())\n          } else {\n            subscriber.complete()\n          }\n        },\n      )\n\n      if (!emitted) subscriber.next(mapGroups(groups))\n\n      return () => {\n        sub.unsubscribe()\n        groups.forEach((g) => {\n          g.source.unsubscribe()\n          g.subscription.unsubscribe()\n        })\n      }\n    },\n  ).pipe(shareLatest())\n\n  return [\n    (key: K) => getGroupedObservable(groupedObservables$, key),\n    groupedObservables$.pipe(map((x) => Array.from(x.keys()))),\n  ]\n}\n\ninterface InnerGroup<T, K, R> {\n  source: Subject<T>\n  observable: GroupedObservable<K, R>\n  subscription: Subscription\n}\n\nfunction mapGroups<T, K, R>(\n  groups: Map<K, InnerGroup<T, K, R>>,\n): Map<K, GroupedObservable<K, R>> {\n  return new Map(\n    Array.from(groups.entries()).map(([key, group]) => [key, group.observable]),\n  )\n}\n\nconst getGroupedObservable = <K, T>(\n  source$: Observable<Map<K, GroupedObservable<K, T>>>,\n  key: K,\n) => {\n  const result = new Observable<T>((observer) => {\n    let innerSub: Subscription | undefined\n    let outterSub: Subscription = source$.subscribe(\n      (n) => {\n        innerSub = innerSub || n.get(key)?.subscribe(observer)\n      },\n      (e) => {\n        observer.error(e)\n      },\n      () => {\n        observer.complete()\n      },\n    )\n    return () => {\n      innerSub?.unsubscribe()\n      outterSub.unsubscribe()\n    }\n  }) as GroupedObservable<K, T>\n  ;(result as any).key = key\n  return result\n}\n", "import { ObservableInput, from, Observable } from \"rxjs\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\nimport { defaultStart } from \"./internal-utils\"\n\n/**\n * A RxJS creation operator that prepends a SUSPENSE on the source observable.\n *\n * @param source$ Source observable\n */\nexport const suspend: <T>(\n  source$: ObservableInput<T>,\n) => Observable<T | typeof SUSPENSE> = <T>(source$: ObservableInput<T>) =>\n  defaultStart(SUSPENSE)(from(source$)) as any\n", "import { Observable } from \"rxjs\"\n\nexport const defaultStart =\n  <T, D>(value: D) =>\n  (source$: Observable<T>) =>\n    new Observable<T | D>((observer) => {\n      let emitted = false\n      const subscription = source$.subscribe(\n        (x) => {\n          emitted = true\n          observer.next(x)\n        },\n        (e) => {\n          observer.error(e)\n        },\n        () => {\n          observer.complete()\n        },\n      )\n\n      if (!emitted) {\n        observer.next(value)\n      }\n\n      return subscription\n    })\n", "import { suspend } from \"./suspend\"\nimport { OperatorFunction } from \"rxjs\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\n\n/**\n * A RxJS pipeable operator that prepends a SUSPENSE on the source observable.\n */\nexport const suspended = <T>(): OperatorFunction<T, T | typeof SUSPENSE> =>\n  suspend\n", "import { ObservableInput, OperatorFunction, ObservedValueOf, pipe } from \"rxjs\"\nimport { switchMap } from \"rxjs/operators\"\nimport { suspend } from \"./suspend\"\nimport { SUSPENSE } from \"@react-rxjs/core\"\n\n/**\n * Same behaviour as rxjs' `switchMap`, but prepending every new event with\n * SUSPENSE.\n *\n * @param fn Projection function\n */\nexport const switchMapSuspended = <T, O extends ObservableInput<any>>(\n  project: (value: T, index: number) => O,\n): OperatorFunction<T, ObservedValueOf<O> | typeof SUSPENSE> =>\n  pipe(switchMap((x, index) => suspend(project(x, index))))\n", "import { Observable, Subject, MonoTypeOperatorFunction } from \"rxjs\"\nimport { tap } from \"rxjs/operators\"\n\n/**\n * A creation operator that helps at creating observables that have circular\n * dependencies\n *\n * @returns [1, 2]\n * 1. The inner subject as an Observable\n * 2. A pipable operator that taps into the inner Subject\n */\nexport const selfDependant = <T>(): [\n  Observable<T>,\n  () => MonoTypeOperatorFunction<T>,\n] => {\n  const mirrored$ = new Subject<T>()\n  return [\n    mirrored$.asObservable(),\n    () => tap(mirrored$) as MonoTypeOperatorFunction<T>,\n  ]\n}\n", "import { Observable } from \"rxjs\"\nimport { bind, SUSPENSE } from \"@react-rxjs/core\"\n\ntype SubstractTuples<A1, A2> = A2 extends [unknown, ...infer Rest2]\n  ? A1 extends [unknown, ...infer Rest1]\n    ? SubstractTuples<Rest1, Rest2>\n    : []\n  : A1\n\nconst execSelf = <T>(fn: () => T) => fn()\n\n/**\n * Returns a version of bind where its hook will have the first parameters bound\n * the results of the provided functions\n *\n * @param {...React.Context} context - The React.Context that should be bound to the hook.\n */\nexport function contextBinder<\n  A extends (() => any)[],\n  OT extends {\n    [K in keyof A]: A[K] extends () => infer V ? V : unknown\n  },\n>(\n  ...args: A\n): <AA extends any[], T, ARGS extends [...OT, ...AA]>(\n  getObservable: (...args: ARGS) => Observable<T>,\n  defaultValue?: T | undefined,\n) => [\n  (...args: SubstractTuples<ARGS, OT>) => Exclude<T, typeof SUSPENSE>,\n  (...args: ARGS) => Observable<T>,\n]\nexport function contextBinder(...args: any[]) {\n  const useArgs = () => args.map(execSelf)\n  return function () {\n    const [hook, getter] = bind.apply(null, arguments as any) as any\n    return [(...args: any[]) => (hook as any)(...useArgs(), ...args), getter]\n  } as any\n}\n", "import { Observable } from \"rxjs\"\nimport { createSignal } from \"./createSignal\"\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener<A extends unknown[], T>(\n  mapper: (...args: A) => T,\n): [Observable<T>, (...args: A) => void]\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener(): [Observable<void>, () => void]\n\n/** @deprecated createListener is deprecated and it will be removed in the next version, please use createSignal. */\nexport function createListener<T>(): [Observable<T>, (payload: T) => void]\n\n/**\n * Creates a void signal. It's sugar for splitting the Observer and the Observable of a signal.\n *\n * @returns [1, 2]\n * 1. The Observable\n * 2. The emitter function.\n */\nexport function createListener(...args: any[]) {\n  return (createSignal as any)(...args)\n}\n"],
  "mappings": "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",
  "names": []
}
