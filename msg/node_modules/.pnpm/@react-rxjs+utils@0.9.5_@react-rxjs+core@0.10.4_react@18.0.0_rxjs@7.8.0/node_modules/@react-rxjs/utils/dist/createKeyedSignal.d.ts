import { GroupedObservable } from "rxjs";
/**
 * Creates a "keyed" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.
 *
 * @returns [1, 2]
 * 1. The getter function that returns the GroupedObservable<T, T>
 * 2. The emitter function.
 */
export declare function createKeyedSignal<T>(): [
    (key: T) => GroupedObservable<T, T>,
    (key: T) => void
];
/**
 * Creates a "keyed" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.
 *
 * @param keySelector a function that extracts the key from the emitted value
 * @returns [1, 2]
 * 1. The getter function that returns the GroupedObservable<K, T>
 * 2. The emitter function.
 */
export declare function createKeyedSignal<K, T>(): [
    (key: K) => GroupedObservable<K, T>,
    (key: K, value: T) => void
];
/**
 * Creates a "keyed" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.
 *
 * @param keySelector a function that extracts the key from the emitted value
 * @returns [1, 2]
 * 1. The getter function that returns the GroupedObservable<K, T>
 * 2. The emitter function.
 */
export declare function createKeyedSignal<K, T>(keySelector: (signal: T) => K): [(key: K) => GroupedObservable<K, T>, (signal: T) => void];
/**
 * Creates a "keyed" signal. It's sugar for splitting the Observer and the Observable of a keyed signal.
 *
 * @param keySelector a function that extracts the key from the emitted value
 * @param mapper a function that maps the arguments of the emitter function to the value of the GroupedObservable
 * @returns [1, 2]
 * 1. The getter function that returns the GroupedObservable<K, T>
 * 2. The emitter function (...args: any[]) => T.
 */
export declare function createKeyedSignal<K, T, A extends any[]>(keySelector: (signal: T) => K, mapper: (...args: A) => T): [(key: K) => GroupedObservable<K, T>, (...args: A) => void];
