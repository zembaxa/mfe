var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, copyDefault, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && (copyDefault || key !== "default"))
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toCommonJS = /* @__PURE__ */ ((cache) => {
  return (module2, temp) => {
    return cache && cache.get(module2) || (temp = __reExport(__markAsModule({}), module2, 1), cache && cache.set(module2, temp), temp);
  };
})(typeof WeakMap !== "undefined" ? /* @__PURE__ */ new WeakMap() : 0);

// src/index.tsx
var src_exports = {};
__export(src_exports, {
  combineKeys: () => combineKeys,
  contextBinder: () => contextBinder,
  createKeyedSignal: () => createKeyedSignal,
  createListener: () => createListener,
  createSignal: () => createSignal,
  mergeWithKey: () => mergeWithKey,
  partitionByKey: () => partitionByKey,
  selfDependant: () => selfDependant,
  suspend: () => suspend,
  suspended: () => suspended,
  switchMapSuspended: () => switchMapSuspended
});

// src/combineKeys.ts
var import_rxjs = require("rxjs");
var combineKeys = (keys$, getInner$) => new import_rxjs.Observable((observer) => {
  const innerSubscriptions = /* @__PURE__ */ new Map();
  let changes = /* @__PURE__ */ new Set();
  const currentValue = /* @__PURE__ */ new Map();
  let updatingSource = false;
  let isPristine = true;
  const next = () => {
    if (!updatingSource) {
      const result = Object.assign(new Map(currentValue), {
        changes
      });
      changes = /* @__PURE__ */ new Set();
      isPristine = false;
      observer.next(result);
    }
  };
  const subscription = keys$.subscribe((nextKeysArr) => {
    updatingSource = true;
    const nextKeys = new Set(nextKeysArr);
    innerSubscriptions.forEach((sub, key) => {
      if (!nextKeys.has(key)) {
        sub.unsubscribe();
        innerSubscriptions.delete(key);
        if (currentValue.has(key)) {
          changes.add(key);
          currentValue.delete(key);
        }
      } else {
        nextKeys.delete(key);
      }
    });
    nextKeys.forEach((key) => {
      innerSubscriptions.set(key, getInner$(key).subscribe((x) => {
        if (!currentValue.has(key) || currentValue.get(key) !== x) {
          changes.add(key);
          currentValue.set(key, x);
          next();
        }
      }, (e) => {
        observer.error(e);
      }));
    });
    updatingSource = false;
    if (changes.size || isPristine && !nextKeys.size)
      next();
  }, (e) => {
    observer.error(e);
  }, () => {
    observer.complete();
  });
  return () => {
    subscription.unsubscribe();
    innerSubscriptions.forEach((sub) => {
      sub.unsubscribe();
    });
  };
});

// src/createSignal.ts
var import_rxjs2 = require("rxjs");
function createSignal(mapper = import_rxjs2.identity) {
  const subject = new import_rxjs2.Subject();
  return [subject.asObservable(), (...args) => subject.next(mapper(...args))];
}

// src/createKeyedSignal.ts
var import_rxjs3 = require("rxjs");
function createKeyedSignal(keySelector, mapper) {
  const observersMap = /* @__PURE__ */ new Map();
  return [
    (key) => {
      const res = new import_rxjs3.Observable((observer) => {
        if (!observersMap.has(key)) {
          observersMap.set(key, /* @__PURE__ */ new Set());
        }
        const set = observersMap.get(key);
        set.add(observer);
        return () => {
          set.delete(observer);
          if (set.size === 0) {
            observersMap.delete(key);
          }
        };
      });
      res.key = key;
      return res;
    },
    (...args) => {
      var _a;
      const payload = mapper ? mapper(...args) : args.length === 2 ? args[1] : args[0];
      const key = keySelector ? keySelector(payload) : args[0];
      (_a = observersMap.get(key)) == null ? void 0 : _a.forEach((o) => {
        o.next(payload);
      });
    }
  ];
}

// src/mergeWithKey.ts
var import_rxjs4 = require("rxjs");
var import_operators = require("rxjs/operators");
var mergeWithKey = (input, ...optionalArgs) => (0, import_rxjs4.merge)(...Object.entries(input).map(([type, stream]) => (0, import_rxjs4.from)(stream).pipe((0, import_operators.map)((payload) => ({ type, payload })))).concat(optionalArgs));

// src/partitionByKey.ts
var import_core = require("@react-rxjs/core");
var import_rxjs5 = require("rxjs");
var import_operators2 = require("rxjs/operators");
function partitionByKey(stream, keySelector, streamSelector) {
  const groupedObservables$ = new import_rxjs5.Observable((subscriber) => {
    const groups = /* @__PURE__ */ new Map();
    let emitted = false;
    let sourceCompleted = false;
    const sub = stream.subscribe((x) => {
      const key = keySelector(x);
      if (groups.has(key)) {
        return groups.get(key).source.next(x);
      }
      const subject = new import_rxjs5.Subject();
      const res = (0, import_core.shareLatest)()((streamSelector || import_rxjs5.identity)(subject, key));
      res.key = key;
      const innerGroup = {
        source: subject,
        observable: res,
        subscription: new import_rxjs5.Subscription()
      };
      groups.set(key, innerGroup);
      innerGroup.subscription = res.subscribe(import_rxjs5.noop, (e) => subscriber.error(e), () => {
        groups.delete(key);
        subscriber.next(mapGroups(groups));
        if (groups.size === 0 && sourceCompleted) {
          subscriber.complete();
        }
      });
      subject.next(x);
      subscriber.next(mapGroups(groups));
      emitted = true;
    }, (e) => {
      sourceCompleted = true;
      if (groups.size) {
        groups.forEach((g) => g.source.error(e));
      } else {
        subscriber.error(e);
      }
    }, () => {
      sourceCompleted = true;
      if (groups.size) {
        groups.forEach((g) => g.source.complete());
      } else {
        subscriber.complete();
      }
    });
    if (!emitted)
      subscriber.next(mapGroups(groups));
    return () => {
      sub.unsubscribe();
      groups.forEach((g) => {
        g.source.unsubscribe();
        g.subscription.unsubscribe();
      });
    };
  }).pipe((0, import_core.shareLatest)());
  return [
    (key) => getGroupedObservable(groupedObservables$, key),
    groupedObservables$.pipe((0, import_operators2.map)((x) => Array.from(x.keys())))
  ];
}
function mapGroups(groups) {
  return new Map(Array.from(groups.entries()).map(([key, group]) => [key, group.observable]));
}
var getGroupedObservable = (source$, key) => {
  const result = new import_rxjs5.Observable((observer) => {
    let innerSub;
    let outterSub = source$.subscribe((n) => {
      var _a;
      innerSub = innerSub || ((_a = n.get(key)) == null ? void 0 : _a.subscribe(observer));
    }, (e) => {
      observer.error(e);
    }, () => {
      observer.complete();
    });
    return () => {
      innerSub == null ? void 0 : innerSub.unsubscribe();
      outterSub.unsubscribe();
    };
  });
  result.key = key;
  return result;
};

// src/suspend.ts
var import_rxjs7 = require("rxjs");
var import_core2 = require("@react-rxjs/core");

// src/internal-utils.ts
var import_rxjs6 = require("rxjs");
var defaultStart = (value) => (source$) => new import_rxjs6.Observable((observer) => {
  let emitted = false;
  const subscription = source$.subscribe((x) => {
    emitted = true;
    observer.next(x);
  }, (e) => {
    observer.error(e);
  }, () => {
    observer.complete();
  });
  if (!emitted) {
    observer.next(value);
  }
  return subscription;
});

// src/suspend.ts
var suspend = (source$) => defaultStart(import_core2.SUSPENSE)((0, import_rxjs7.from)(source$));

// src/suspended.ts
var suspended = () => suspend;

// src/switchMapSuspended.ts
var import_rxjs8 = require("rxjs");
var import_operators3 = require("rxjs/operators");
var switchMapSuspended = (project) => (0, import_rxjs8.pipe)((0, import_operators3.switchMap)((x, index) => suspend(project(x, index))));

// src/selfDependant.ts
var import_rxjs9 = require("rxjs");
var import_operators4 = require("rxjs/operators");
var selfDependant = () => {
  const mirrored$ = new import_rxjs9.Subject();
  return [
    mirrored$.asObservable(),
    () => (0, import_operators4.tap)(mirrored$)
  ];
};

// src/contextBinder.ts
var import_core3 = require("@react-rxjs/core");
var execSelf = (fn) => fn();
function contextBinder(...args) {
  const useArgs = () => args.map(execSelf);
  return function() {
    const [hook, getter] = import_core3.bind.apply(null, arguments);
    return [(...args2) => hook(...useArgs(), ...args2), getter];
  };
}

// src/createListener.ts
function createListener(...args) {
  return createSignal(...args);
}
module.exports = __toCommonJS(src_exports);
//# sourceMappingURL=utils.cjs.development.js.map
