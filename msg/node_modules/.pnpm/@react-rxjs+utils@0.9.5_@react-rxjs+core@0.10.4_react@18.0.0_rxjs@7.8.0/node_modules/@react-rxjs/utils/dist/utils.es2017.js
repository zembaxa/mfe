// src/combineKeys.ts
import { Observable } from "rxjs";
var combineKeys = (keys$, getInner$) => new Observable((observer) => {
  const innerSubscriptions = /* @__PURE__ */ new Map();
  let changes = /* @__PURE__ */ new Set();
  const currentValue = /* @__PURE__ */ new Map();
  let updatingSource = false;
  let isPristine = true;
  const next = () => {
    if (!updatingSource) {
      const result = Object.assign(new Map(currentValue), {
        changes
      });
      changes = /* @__PURE__ */ new Set();
      isPristine = false;
      observer.next(result);
    }
  };
  const subscription = keys$.subscribe((nextKeysArr) => {
    updatingSource = true;
    const nextKeys = new Set(nextKeysArr);
    innerSubscriptions.forEach((sub, key) => {
      if (!nextKeys.has(key)) {
        sub.unsubscribe();
        innerSubscriptions.delete(key);
        if (currentValue.has(key)) {
          changes.add(key);
          currentValue.delete(key);
        }
      } else {
        nextKeys.delete(key);
      }
    });
    nextKeys.forEach((key) => {
      innerSubscriptions.set(key, getInner$(key).subscribe((x) => {
        if (!currentValue.has(key) || currentValue.get(key) !== x) {
          changes.add(key);
          currentValue.set(key, x);
          next();
        }
      }, (e) => {
        observer.error(e);
      }));
    });
    updatingSource = false;
    if (changes.size || isPristine && !nextKeys.size)
      next();
  }, (e) => {
    observer.error(e);
  }, () => {
    observer.complete();
  });
  return () => {
    subscription.unsubscribe();
    innerSubscriptions.forEach((sub) => {
      sub.unsubscribe();
    });
  };
});

// src/createSignal.ts
import { identity, Subject } from "rxjs";
function createSignal(mapper = identity) {
  const subject = new Subject();
  return [subject.asObservable(), (...args) => subject.next(mapper(...args))];
}

// src/createKeyedSignal.ts
import { Observable as Observable3 } from "rxjs";
function createKeyedSignal(keySelector, mapper) {
  const observersMap = /* @__PURE__ */ new Map();
  return [
    (key) => {
      const res = new Observable3((observer) => {
        if (!observersMap.has(key)) {
          observersMap.set(key, /* @__PURE__ */ new Set());
        }
        const set = observersMap.get(key);
        set.add(observer);
        return () => {
          set.delete(observer);
          if (set.size === 0) {
            observersMap.delete(key);
          }
        };
      });
      res.key = key;
      return res;
    },
    (...args) => {
      var _a;
      const payload = mapper ? mapper(...args) : args.length === 2 ? args[1] : args[0];
      const key = keySelector ? keySelector(payload) : args[0];
      (_a = observersMap.get(key)) == null ? void 0 : _a.forEach((o) => {
        o.next(payload);
      });
    }
  ];
}

// src/mergeWithKey.ts
import { merge, from } from "rxjs";
import { map } from "rxjs/operators";
var mergeWithKey = (input, ...optionalArgs) => merge(...Object.entries(input).map(([type, stream]) => from(stream).pipe(map((payload) => ({ type, payload })))).concat(optionalArgs));

// src/partitionByKey.ts
import { shareLatest } from "@react-rxjs/core";
import {
  noop,
  Observable as Observable5,
  Subject as Subject2,
  Subscription as Subscription2,
  identity as identity2
} from "rxjs";
import { map as map2 } from "rxjs/operators";
function partitionByKey(stream, keySelector, streamSelector) {
  const groupedObservables$ = new Observable5((subscriber) => {
    const groups = /* @__PURE__ */ new Map();
    let emitted = false;
    let sourceCompleted = false;
    const sub = stream.subscribe((x) => {
      const key = keySelector(x);
      if (groups.has(key)) {
        return groups.get(key).source.next(x);
      }
      const subject = new Subject2();
      const res = shareLatest()((streamSelector || identity2)(subject, key));
      res.key = key;
      const innerGroup = {
        source: subject,
        observable: res,
        subscription: new Subscription2()
      };
      groups.set(key, innerGroup);
      innerGroup.subscription = res.subscribe(noop, (e) => subscriber.error(e), () => {
        groups.delete(key);
        subscriber.next(mapGroups(groups));
        if (groups.size === 0 && sourceCompleted) {
          subscriber.complete();
        }
      });
      subject.next(x);
      subscriber.next(mapGroups(groups));
      emitted = true;
    }, (e) => {
      sourceCompleted = true;
      if (groups.size) {
        groups.forEach((g) => g.source.error(e));
      } else {
        subscriber.error(e);
      }
    }, () => {
      sourceCompleted = true;
      if (groups.size) {
        groups.forEach((g) => g.source.complete());
      } else {
        subscriber.complete();
      }
    });
    if (!emitted)
      subscriber.next(mapGroups(groups));
    return () => {
      sub.unsubscribe();
      groups.forEach((g) => {
        g.source.unsubscribe();
        g.subscription.unsubscribe();
      });
    };
  }).pipe(shareLatest());
  return [
    (key) => getGroupedObservable(groupedObservables$, key),
    groupedObservables$.pipe(map2((x) => Array.from(x.keys())))
  ];
}
function mapGroups(groups) {
  return new Map(Array.from(groups.entries()).map(([key, group]) => [key, group.observable]));
}
var getGroupedObservable = (source$, key) => {
  const result = new Observable5((observer) => {
    let innerSub;
    let outterSub = source$.subscribe((n) => {
      var _a;
      innerSub = innerSub || ((_a = n.get(key)) == null ? void 0 : _a.subscribe(observer));
    }, (e) => {
      observer.error(e);
    }, () => {
      observer.complete();
    });
    return () => {
      innerSub == null ? void 0 : innerSub.unsubscribe();
      outterSub.unsubscribe();
    };
  });
  result.key = key;
  return result;
};

// src/suspend.ts
import { from as from2 } from "rxjs";
import { SUSPENSE } from "@react-rxjs/core";

// src/internal-utils.ts
import { Observable as Observable6 } from "rxjs";
var defaultStart = (value) => (source$) => new Observable6((observer) => {
  let emitted = false;
  const subscription = source$.subscribe((x) => {
    emitted = true;
    observer.next(x);
  }, (e) => {
    observer.error(e);
  }, () => {
    observer.complete();
  });
  if (!emitted) {
    observer.next(value);
  }
  return subscription;
});

// src/suspend.ts
var suspend = (source$) => defaultStart(SUSPENSE)(from2(source$));

// src/suspended.ts
var suspended = () => suspend;

// src/switchMapSuspended.ts
import { pipe } from "rxjs";
import { switchMap } from "rxjs/operators";
var switchMapSuspended = (project) => pipe(switchMap((x, index) => suspend(project(x, index))));

// src/selfDependant.ts
import { Subject as Subject3 } from "rxjs";
import { tap } from "rxjs/operators";
var selfDependant = () => {
  const mirrored$ = new Subject3();
  return [
    mirrored$.asObservable(),
    () => tap(mirrored$)
  ];
};

// src/contextBinder.ts
import { bind } from "@react-rxjs/core";
var execSelf = (fn) => fn();
function contextBinder(...args) {
  const useArgs = () => args.map(execSelf);
  return function() {
    const [hook, getter] = bind.apply(null, arguments);
    return [(...args2) => hook(...useArgs(), ...args2), getter];
  };
}

// src/createListener.ts
function createListener(...args) {
  return createSignal(...args);
}
export {
  combineKeys,
  contextBinder,
  createKeyedSignal,
  createListener,
  createSignal,
  mergeWithKey,
  partitionByKey,
  selfDependant,
  suspend,
  suspended,
  switchMapSuspended
};
//# sourceMappingURL=utils.es2017.js.map
