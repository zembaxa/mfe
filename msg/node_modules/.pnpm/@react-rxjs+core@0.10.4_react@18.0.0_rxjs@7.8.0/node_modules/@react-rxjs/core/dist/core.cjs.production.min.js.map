{
  "version": 3,
  "sources": ["../src/index.tsx", "../src/internal/empty-value.ts", "../src/bind/connectFactoryObservable.ts", "../src/bind/connectObservable.ts", "../src/bind/index.ts", "../src/shareLatest.ts", "../src/stateJsx.tsx", "../src/useStateObservable.ts", "../src/internal/useSyncExternalStoreCjs.ts", "../src/Subscribe.tsx"],
  "sourcesContent": ["export type {\n  AddStopArg,\n  DefaultedStateObservable,\n  EmptyObservableError,\n  NoSubscribersError,\n  PipeState,\n  StateObservable,\n  StatePromise,\n  WithDefaultOperator,\n} from \"@rx-state/core\"\nexport {\n  liftSuspense,\n  sinkSuspense,\n  SUSPENSE,\n  withDefault,\n} from \"@rx-state/core\"\nexport { bind } from \"./bind\"\nexport { shareLatest } from \"./shareLatest\"\nexport { state } from \"./stateJsx\"\nexport { RemoveSubscribe, Subscribe } from \"./Subscribe\"\nexport { useStateObservable } from \"./useStateObservable\"\n", "export const EMPTY_VALUE: any = {}\n", "import { Observable } from \"rxjs\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\nimport { state, StateObservable, SUSPENSE } from \"@rx-state/core\"\nimport { useStateObservable } from \"../\"\n\n/**\n * Accepts: A factory function that returns an Observable.\n *\n * Returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @param getObservable Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport default function connectFactoryObservable<A extends [], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n): [(...args: A) => Exclude<O, SUSPENSE>, (...args: A) => StateObservable<O>] {\n  const args:\n    | [(...args: A) => Observable<O>]\n    | [(...args: A) => Observable<O>, O | ((...args: A) => O)] =\n    defaultValue === EMPTY_VALUE\n      ? [getObservable]\n      : [getObservable, defaultValue]\n\n  const obs = state(...(args as [(...args: A) => Observable<O>]))\n  return [\n    (...input: A) => useStateObservable(obs(...(input as any))),\n    obs as any,\n  ]\n}\n", "import { EMPTY_VALUE } from \"../internal/empty-value\"\nimport { Observable } from \"rxjs\"\nimport { useStateObservable } from \"../\"\nimport { state } from \"@rx-state/core\"\n\n/**\n * Accepts: An Observable.\n *\n * Returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n *\n * @param observable Source observable to be used by the hook.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport default function connectObservable<T>(\n  observable: Observable<T>,\n  defaultValue: T,\n) {\n  const sharedObservable$ =\n    defaultValue === EMPTY_VALUE\n      ? state(observable)\n      : state(observable, defaultValue)\n\n  const useStaticObservable = () => useStateObservable(sharedObservable$ as any)\n  return [useStaticObservable, sharedObservable$] as const\n}\n", "import { Observable } from \"rxjs\"\nimport connectFactoryObservable from \"./connectFactoryObservable\"\nimport connectObservable from \"./connectObservable\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\nimport {\n  StateObservable,\n  DefaultedStateObservable,\n  SUSPENSE,\n} from \"@rx-state/core\"\n\n// Adds an additional \"stop\" argument to prevent using factory functions\n// inside high-order-functions directly (e.g. switchMap(factory$))\ntype AddStopArg<A extends Array<any>> = number extends A[\"length\"]\n  ? A\n  : [...args: A, _stop?: undefined]\n\n/**\n * Binds an observable to React\n *\n * @param {Observable<T>} observable - Source observable to be used by the hook.\n * @returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function bind<T>(\n  observable: Observable<T>,\n): [() => Exclude<T, typeof SUSPENSE>, StateObservable<T>]\n\n/**\n * Binds an observable to React\n *\n * @param {Observable<T>} observable - Source observable to be used by the hook.\n * @param {T} defaultValue - Default value that will be used if the observable\n * has not emitted any values.\n * @returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n */\nexport function bind<T>(\n  observable: Observable<T>,\n  defaultValue: T,\n): [() => Exclude<T, typeof SUSPENSE>, DefaultedStateObservable<T>]\n\n/**\n * Binds a factory observable to React\n *\n * @param {(...args: any) => Observable<T>} getObservable - Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n * @returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function bind<A extends unknown[], O>(\n  getObservable: (...args: A) => Observable<O>,\n): [\n  (...args: AddStopArg<A>) => Exclude<O, typeof SUSPENSE>,\n  (...args: AddStopArg<A>) => StateObservable<O>,\n]\n\n/**\n * Binds a factory observable to React\n *\n * @param {(...args: any) => Observable<T>} getObservable - Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n * @param {T} defaultValue - Function or value that will be used of the observable\n * has not emitted.\n * @returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n */\nexport function bind<A extends unknown[], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n): [\n  (...args: AddStopArg<A>) => Exclude<O, typeof SUSPENSE>,\n  (...args: AddStopArg<A>) => DefaultedStateObservable<O>,\n]\n\nexport function bind(observable: any, defaultValue?: any) {\n  return (\n    typeof observable === \"function\"\n      ? (connectFactoryObservable as any)\n      : connectObservable\n  )(observable, arguments.length > 1 ? defaultValue : EMPTY_VALUE)\n}\n", "import { MonoTypeOperatorFunction, ReplaySubject, share } from \"rxjs\"\n\n/**\n * A RxJS pipeable operator which shares and replays the latest emitted value.\n * It's the equivalent of:\n *\n * ```ts\n * share<T>({\n *   connector: () => new ReplaySubject<T>(1),\n *   resetOnError: true,\n *   resetOnComplete: true,\n *   resetOnRefCountZero: true,\n * })\n * ```\n */\nexport const shareLatest = <T>(): MonoTypeOperatorFunction<T> =>\n  share<T>({\n    connector: () => new ReplaySubject<T>(1),\n    resetOnError: true,\n    resetOnComplete: true,\n    resetOnRefCountZero: true,\n  })\n", "import { state as coreState, StateObservable } from \"@rx-state/core\"\nimport React, { createElement, ReactElement } from \"react\"\nimport { useStateObservable } from \"./useStateObservable\"\n\ndeclare module \"@rx-state/core\" {\n  interface StateObservable<T> extends ReactElement {}\n}\n\nexport const state: typeof coreState = (...args: any[]): any => {\n  const result = (coreState as any)(...args)\n\n  if (typeof result === \"function\") {\n    return (...args: any[]) => enhanceState(result(...args))\n  }\n  return enhanceState(result)\n}\n\nconst cache = new WeakMap<StateObservable<any>, React.ReactNode>()\nfunction enhanceState<T>(state$: StateObservable<T>) {\n  if (!cache.has(state$))\n    cache.set(\n      state$,\n      createElement(() => useStateObservable(state$) as any, {}),\n    )\n\n  const originalPipeState = state$.pipeState.bind(state$)\n  return Object.assign(state$, cache.get(state$)!, {\n    pipeState: (...operators: any[]) =>\n      enhanceState((originalPipeState as any)(...operators)),\n  })\n}\n", "import {\n  DefaultedStateObservable,\n  liftSuspense,\n  NoSubscribersError,\n  StateObservable,\n  StatePromise,\n  SUSPENSE,\n} from \"@rx-state/core\"\nimport { useRef, useState } from \"react\"\nimport useSyncExternalStore from \"./internal/useSyncExternalStore\"\nimport { useSubscription } from \"./Subscribe\"\n\ntype VoidCb = () => void\n\ninterface Ref<T> {\n  source$: StateObservable<T>\n  args: [(cb: VoidCb) => VoidCb, () => Exclude<T, SUSPENSE>]\n}\n\nexport const useStateObservable = <O>(\n  source$: StateObservable<O>,\n): Exclude<O, typeof SUSPENSE> => {\n  const subscription = useSubscription()\n  const [, setError] = useState()\n  const callbackRef = useRef<Ref<O>>()\n\n  if (!callbackRef.current) {\n    const getValue = (src: StateObservable<O>) => {\n      const result = src.getValue()\n      if (result instanceof StatePromise)\n        throw result.catch((e) => {\n          if (e instanceof NoSubscribersError) return e\n          throw e\n        })\n      return result as any\n    }\n\n    const gv: <T>() => Exclude<T, typeof SUSPENSE> = () => {\n      const src = callbackRef.current!.source$ as DefaultedStateObservable<O>\n      if (!src.getRefCount() && !src.getDefaultValue) {\n        if (!subscription) throw new Error(\"Missing Subscribe!\")\n        subscription(src)\n      }\n      return getValue(src)\n    }\n\n    callbackRef.current = {\n      source$: null as any,\n      args: [, gv] as any,\n    }\n  }\n\n  const ref = callbackRef.current\n  if (ref.source$ !== source$) {\n    ref.source$ = source$\n    ref.args[0] = (next: () => void) => {\n      const subscription = liftSuspense()(source$).subscribe({\n        next,\n        error: (e) => {\n          setError(() => {\n            throw e\n          })\n        },\n      })\n      return () => {\n        subscription.unsubscribe()\n      }\n    }\n  }\n\n  return useSyncExternalStore(...ref!.args)\n}\n", "export { useSyncExternalStore as default } from \"use-sync-external-store/shim\"\n", "import React, {\n  useState,\n  Suspense,\n  useEffect,\n  ReactNode,\n  useRef,\n  createContext,\n  useContext,\n} from \"react\"\nimport { Observable, Subscription } from \"rxjs\"\nimport { liftSuspense, StateObservable } from \"@rx-state/core\"\nimport { EMPTY_VALUE } from \"./internal/empty-value\"\n\nconst SubscriptionContext = createContext<\n  ((src: StateObservable<any>) => void) | null\n>(null)\nconst { Provider } = SubscriptionContext\nexport const useSubscription = () => useContext(SubscriptionContext)\n\nconst p = Promise.resolve()\nconst Throw = () => {\n  throw p\n}\n\n/**\n * A React Component that:\n * - collects the subscriptions of its children and it unsubscribes them when\n * the component unmounts.\n * - if a source$ property is used, then it ensures that the subscription to the\n * observable will exist before the children gets rendered, and it unsubscribes\n * from it when the component unmounts.\n *\n * If the fallback property is used, then the component will create a Suspense\n * boundary with the provided JSX Element, otherwise it will render null until\n * the subscription exists.\n *\n * @param [source$] (=undefined) - Source observable that the Component will\n * subscrib to before it renders its children.\n * @param [fallback] (=null) - JSX Element to be used by the Suspense boundary.\n *\n * @remarks This Component doesn't trigger any updates from the source$.\n */\nexport const Subscribe: React.FC<{\n  children?: React.ReactNode | undefined\n  source$?: Observable<any>\n  fallback?: NonNullable<ReactNode> | null\n}> = ({ source$, children, fallback }) => {\n  const subscriptionRef = useRef<{\n    s: Subscription\n    u: (source: StateObservable<any>) => void\n  }>()\n\n  if (!subscriptionRef.current) {\n    const s = new Subscription()\n    subscriptionRef.current = {\n      s,\n      u: (src) => {\n        let error = EMPTY_VALUE\n        let synchronous = true\n        s.add(\n          liftSuspense()(src).subscribe({\n            error: (e) => {\n              if (synchronous) {\n                // Can't setState of this component when another one is rendering.\n                error = e\n                return\n              }\n              setSubscribedSource(() => {\n                throw e\n              })\n            },\n          }),\n        )\n        synchronous = false\n        if (error !== EMPTY_VALUE) {\n          throw error\n        }\n      },\n    }\n  }\n\n  const [subscribedSource, setSubscribedSource] = useState<\n    Observable<any> | null | undefined\n  >(null)\n\n  if (subscribedSource !== null && subscribedSource !== source$) {\n    if (source$ === undefined) {\n      setSubscribedSource(source$)\n    } else {\n      try {\n        ;(source$ as any).getValue()\n        setSubscribedSource(source$)\n      } catch (e: any) {}\n    }\n  }\n\n  useEffect(() => {\n    setSubscribedSource(source$)\n    if (!source$) return\n\n    const subscription = liftSuspense()(source$).subscribe({\n      error: (e) =>\n        setSubscribedSource(() => {\n          throw e\n        }),\n    })\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [source$])\n\n  useEffect(() => {\n    return () => {\n      subscriptionRef.current?.s.unsubscribe()\n      subscriptionRef.current = undefined\n    }\n  }, [])\n\n  const actualChildren =\n    subscribedSource === source$ ? (\n      <Provider value={subscriptionRef.current!.u}>{children}</Provider>\n    ) : fallback === undefined ? null : (\n      <Throw />\n    )\n\n  return fallback === undefined ? (\n    actualChildren\n  ) : (\n    <Suspense fallback={fallback}>{actualChildren}</Suspense>\n  )\n}\n\n/**\n * Component that prevents its children from using the parent `Subscribe` boundary\n * to manage their subscriptions.\n */\nexport const RemoveSubscribe: React.FC<{\n  children?: React.ReactNode | undefined\n}> = ({ children }) => <Provider value={null}>{children}</Provider>\n"],
  "mappings": "6iBAAA,kQAUA,MAKO,0BCfA,GAAM,GAAmB,CAAC,ECEjC,MAAiD,0BAsBlC,WACb,EACA,EAC4E,CAQ5E,GAAM,GAAM,YAAM,GAJhB,IAAiB,EACb,CAAC,CAAa,EACd,CAAC,EAAe,CAAY,CAE4B,EAC9D,MAAO,CACL,IAAI,IAAa,EAAmB,EAAI,GAAI,CAAa,CAAC,EAC1D,CACF,CACF,CCrCA,MAAsB,0BAiBP,WACb,EACA,EACA,CACA,GAAM,GACJ,IAAiB,EACb,YAAM,CAAU,EAChB,YAAM,EAAY,CAAY,EAGpC,MAAO,CADqB,IAAM,EAAmB,CAAwB,EAChD,CAAiB,CAChD,CCqEO,WAAc,EAAiB,EAAoB,CACxD,MACE,OAAO,IAAe,WACjB,EACD,GACJ,EAAY,UAAU,OAAS,EAAI,EAAe,CAAW,CACjE,CC1GA,MAA+D,gBAelD,EAAc,IACzB,YAAS,CACP,UAAW,IAAM,GAAI,iBAAiB,CAAC,EACvC,aAAc,GACd,gBAAiB,GACjB,oBAAqB,EACvB,CAAC,ECrBH,MAAoD,0BACpD,EAAmD,iBCDnD,MAOO,0BACP,EAAiC,iBCRjC,MAAgD,wCCAhD,MAQO,oBACP,EAAyC,gBACzC,EAA8C,0BAG9C,GAAM,GAAsB,oBAE1B,IAAI,EACA,CAAE,YAAa,EACR,EAAkB,IAAM,iBAAW,CAAmB,EAE7D,EAAI,QAAQ,QAAQ,EACpB,EAAQ,IAAM,CAClB,KAAM,EACR,EAoBa,EAIR,CAAC,CAAE,UAAS,WAAU,cAAe,CACxC,GAAM,GAAkB,aAGrB,EAEH,GAAI,CAAC,EAAgB,QAAS,CAC5B,GAAM,GAAI,GAAI,gBACd,EAAgB,QAAU,CACxB,IACA,EAAG,AAAC,GAAQ,CACV,GAAI,GAAQ,EACR,EAAc,GAgBlB,GAfA,EAAE,IACA,mBAAa,EAAE,CAAG,EAAE,UAAU,CAC5B,MAAO,AAAC,GAAM,CACZ,GAAI,EAAa,CAEf,EAAQ,EACR,MACF,CACA,EAAoB,IAAM,CACxB,KAAM,EACR,CAAC,CACH,CACF,CAAC,CACH,EACA,EAAc,GACV,IAAU,EACZ,KAAM,EAEV,CACF,CACF,CAEA,GAAM,CAAC,EAAkB,GAAuB,eAE9C,IAAI,EAEN,GAAI,IAAqB,MAAQ,IAAqB,EACpD,GAAI,IAAY,OACd,EAAoB,CAAO,MAE3B,IAAI,CACD,AAAC,EAAgB,SAAS,EAC3B,EAAoB,CAAO,CAC7B,OAAS,EAAP,CAAgB,CAItB,gBAAU,IAAM,CAEd,GADA,EAAoB,CAAO,EACvB,CAAC,EAAS,OAEd,GAAM,GAAe,mBAAa,EAAE,CAAO,EAAE,UAAU,CACrD,MAAO,AAAC,GACN,EAAoB,IAAM,CACxB,KAAM,EACR,CAAC,CACL,CAAC,EACD,MAAO,IAAM,CACX,EAAa,YAAY,CAC3B,CACF,EAAG,CAAC,CAAO,CAAC,EAEZ,gBAAU,IACD,IAAM,CAhHjB,MAiHM,KAAgB,UAAhB,QAAyB,EAAE,cAC3B,EAAgB,QAAU,MAC5B,EACC,CAAC,CAAC,EAEL,GAAM,GACJ,IAAqB,EACnB,wBAAC,GAAS,MAAO,EAAgB,QAAS,GAAI,CAAS,EACrD,IAAa,OAAY,KAC3B,wBAAC,MAAM,EAGX,MAAO,KAAa,OAClB,EAEA,wBAAC,YAAS,SAAU,GAAW,CAAe,CAElD,EAMa,EAER,CAAC,CAAE,cAAe,wBAAC,GAAS,MAAO,MAAO,CAAS,EFvHjD,GAAM,GAAqB,AAChC,GACgC,CAChC,GAAM,GAAe,EAAgB,EAC/B,CAAC,CAAE,GAAY,eAAS,EACxB,EAAc,aAAe,EAEnC,GAAI,CAAC,EAAY,QAAS,CACxB,GAAM,GAAW,AAAC,GAA4B,CAC5C,GAAM,GAAS,EAAI,SAAS,EAC5B,GAAI,YAAkB,gBACpB,KAAM,GAAO,MAAM,AAAC,GAAM,CACxB,GAAI,YAAa,sBAAoB,MAAO,GAC5C,KAAM,EACR,CAAC,EACH,MAAO,EACT,EAEM,EAA2C,IAAM,CACrD,GAAM,GAAM,EAAY,QAAS,QACjC,GAAI,CAAC,EAAI,YAAY,GAAK,CAAC,EAAI,gBAAiB,CAC9C,GAAI,CAAC,EAAc,KAAM,IAAI,OAAM,oBAAoB,EACvD,EAAa,CAAG,CAClB,CACA,MAAO,GAAS,CAAG,CACrB,EAEA,EAAY,QAAU,CACpB,QAAS,KACT,KAAM,CAAC,CAAE,CAAE,CACb,CACF,CAEA,GAAM,GAAM,EAAY,QACxB,MAAI,GAAI,UAAY,GAClB,GAAI,QAAU,EACd,EAAI,KAAK,GAAK,AAAC,GAAqB,CAClC,GAAM,GAAe,mBAAa,EAAE,CAAO,EAAE,UAAU,CACrD,OACA,MAAO,AAAC,GAAM,CACZ,EAAS,IAAM,CACb,KAAM,EACR,CAAC,CACH,CACF,CAAC,EACD,MAAO,IAAM,CACX,EAAa,YAAY,CAC3B,CACF,GAGK,2BAAqB,GAAG,EAAK,IAAI,CAC1C,ED/DO,GAAM,GAA0B,IAAI,IAAqB,CAC9D,GAAM,GAAU,YAAkB,GAAG,CAAI,EAEzC,MAAI,OAAO,IAAW,WACb,IAAI,IAAgB,EAAa,EAAO,GAAG,CAAI,CAAC,EAElD,EAAa,CAAM,CAC5B,EAEM,EAAQ,GAAI,SAClB,WAAyB,EAA4B,CACnD,AAAK,EAAM,IAAI,CAAM,GACnB,EAAM,IACJ,EACA,oBAAc,IAAM,EAAmB,CAAM,EAAU,CAAC,CAAC,CAC3D,EAEF,GAAM,GAAoB,EAAO,UAAU,KAAK,CAAM,EACtD,MAAO,QAAO,OAAO,EAAQ,EAAM,IAAI,CAAM,EAAI,CAC/C,UAAW,IAAI,IACb,EAAc,EAA0B,GAAG,CAAS,CAAC,CACzD,CAAC,CACH",
  "names": []
}
