{
  "version": 3,
  "sources": ["../src/index.tsx", "../src/internal/empty-value.ts", "../src/bind/connectFactoryObservable.ts", "../src/bind/connectObservable.ts", "../src/bind/index.ts", "../src/shareLatest.ts", "../src/stateJsx.tsx", "../src/useStateObservable.ts", "../src/internal/useSyncExternalStore.ts", "../src/Subscribe.tsx"],
  "sourcesContent": ["export type {\n  AddStopArg,\n  DefaultedStateObservable,\n  EmptyObservableError,\n  NoSubscribersError,\n  PipeState,\n  StateObservable,\n  StatePromise,\n  WithDefaultOperator,\n} from \"@rx-state/core\"\nexport {\n  liftSuspense,\n  sinkSuspense,\n  SUSPENSE,\n  withDefault,\n} from \"@rx-state/core\"\nexport { bind } from \"./bind\"\nexport { shareLatest } from \"./shareLatest\"\nexport { state } from \"./stateJsx\"\nexport { RemoveSubscribe, Subscribe } from \"./Subscribe\"\nexport { useStateObservable } from \"./useStateObservable\"\n", "export const EMPTY_VALUE: any = {}\n", "import { Observable } from \"rxjs\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\nimport { state, StateObservable, SUSPENSE } from \"@rx-state/core\"\nimport { useStateObservable } from \"../\"\n\n/**\n * Accepts: A factory function that returns an Observable.\n *\n * Returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @param getObservable Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport default function connectFactoryObservable<A extends [], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n): [(...args: A) => Exclude<O, SUSPENSE>, (...args: A) => StateObservable<O>] {\n  const args:\n    | [(...args: A) => Observable<O>]\n    | [(...args: A) => Observable<O>, O | ((...args: A) => O)] =\n    defaultValue === EMPTY_VALUE\n      ? [getObservable]\n      : [getObservable, defaultValue]\n\n  const obs = state(...(args as [(...args: A) => Observable<O>]))\n  return [\n    (...input: A) => useStateObservable(obs(...(input as any))),\n    obs as any,\n  ]\n}\n", "import { EMPTY_VALUE } from \"../internal/empty-value\"\nimport { Observable } from \"rxjs\"\nimport { useStateObservable } from \"../\"\nimport { state } from \"@rx-state/core\"\n\n/**\n * Accepts: An Observable.\n *\n * Returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n *\n * @param observable Source observable to be used by the hook.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport default function connectObservable<T>(\n  observable: Observable<T>,\n  defaultValue: T,\n) {\n  const sharedObservable$ =\n    defaultValue === EMPTY_VALUE\n      ? state(observable)\n      : state(observable, defaultValue)\n\n  const useStaticObservable = () => useStateObservable(sharedObservable$ as any)\n  return [useStaticObservable, sharedObservable$] as const\n}\n", "import { Observable } from \"rxjs\"\nimport connectFactoryObservable from \"./connectFactoryObservable\"\nimport connectObservable from \"./connectObservable\"\nimport { EMPTY_VALUE } from \"../internal/empty-value\"\nimport {\n  StateObservable,\n  DefaultedStateObservable,\n  SUSPENSE,\n} from \"@rx-state/core\"\n\n// Adds an additional \"stop\" argument to prevent using factory functions\n// inside high-order-functions directly (e.g. switchMap(factory$))\ntype AddStopArg<A extends Array<any>> = number extends A[\"length\"]\n  ? A\n  : [...args: A, _stop?: undefined]\n\n/**\n * Binds an observable to React\n *\n * @param {Observable<T>} observable - Source observable to be used by the hook.\n * @returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function bind<T>(\n  observable: Observable<T>,\n): [() => Exclude<T, typeof SUSPENSE>, StateObservable<T>]\n\n/**\n * Binds an observable to React\n *\n * @param {Observable<T>} observable - Source observable to be used by the hook.\n * @param {T} defaultValue - Default value that will be used if the observable\n * has not emitted any values.\n * @returns [1, 2]\n * 1. A React Hook that yields the latest emitted value of the observable\n * 2. A `sharedLatest` version of the observable. It can be used for composing\n * other streams that depend on it. The shared subscription is closed as soon as\n * there are no subscribers to that observable.\n */\nexport function bind<T>(\n  observable: Observable<T>,\n  defaultValue: T,\n): [() => Exclude<T, typeof SUSPENSE>, DefaultedStateObservable<T>]\n\n/**\n * Binds a factory observable to React\n *\n * @param {(...args: any) => Observable<T>} getObservable - Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n * @returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n *\n * @remarks If the Observable doesn't synchronously emit a value upon the first\n * subscription, then the hook will leverage React Suspense while it's waiting\n * for the first value.\n */\nexport function bind<A extends unknown[], O>(\n  getObservable: (...args: A) => Observable<O>,\n): [\n  (...args: AddStopArg<A>) => Exclude<O, typeof SUSPENSE>,\n  (...args: AddStopArg<A>) => StateObservable<O>,\n]\n\n/**\n * Binds a factory observable to React\n *\n * @param {(...args: any) => Observable<T>} getObservable - Factory of observables. The arguments of this function\n *  will be the ones used in the hook.\n * @param {T} defaultValue - Function or value that will be used of the observable\n * has not emitted.\n * @returns [1, 2]\n * 1. A React Hook function with the same parameters as the factory function.\n *  This hook will yield the latest update from the observable returned from\n *  the factory function.\n * 2. A `sharedLatest` version of the observable generated by the factory\n *  function that can be used for composing other streams that depend on it.\n *  The shared subscription is closed as soon as there are no subscribers to\n *  that observable.\n */\nexport function bind<A extends unknown[], O>(\n  getObservable: (...args: A) => Observable<O>,\n  defaultValue: O | ((...args: A) => O),\n): [\n  (...args: AddStopArg<A>) => Exclude<O, typeof SUSPENSE>,\n  (...args: AddStopArg<A>) => DefaultedStateObservable<O>,\n]\n\nexport function bind(observable: any, defaultValue?: any) {\n  return (\n    typeof observable === \"function\"\n      ? (connectFactoryObservable as any)\n      : connectObservable\n  )(observable, arguments.length > 1 ? defaultValue : EMPTY_VALUE)\n}\n", "import { MonoTypeOperatorFunction, ReplaySubject, share } from \"rxjs\"\n\n/**\n * A RxJS pipeable operator which shares and replays the latest emitted value.\n * It's the equivalent of:\n *\n * ```ts\n * share<T>({\n *   connector: () => new ReplaySubject<T>(1),\n *   resetOnError: true,\n *   resetOnComplete: true,\n *   resetOnRefCountZero: true,\n * })\n * ```\n */\nexport const shareLatest = <T>(): MonoTypeOperatorFunction<T> =>\n  share<T>({\n    connector: () => new ReplaySubject<T>(1),\n    resetOnError: true,\n    resetOnComplete: true,\n    resetOnRefCountZero: true,\n  })\n", "import { state as coreState, StateObservable } from \"@rx-state/core\"\nimport React, { createElement, ReactElement } from \"react\"\nimport { useStateObservable } from \"./useStateObservable\"\n\ndeclare module \"@rx-state/core\" {\n  interface StateObservable<T> extends ReactElement {}\n}\n\nexport const state: typeof coreState = (...args: any[]): any => {\n  const result = (coreState as any)(...args)\n\n  if (typeof result === \"function\") {\n    return (...args: any[]) => enhanceState(result(...args))\n  }\n  return enhanceState(result)\n}\n\nconst cache = new WeakMap<StateObservable<any>, React.ReactNode>()\nfunction enhanceState<T>(state$: StateObservable<T>) {\n  if (!cache.has(state$))\n    cache.set(\n      state$,\n      createElement(() => useStateObservable(state$) as any, {}),\n    )\n\n  const originalPipeState = state$.pipeState.bind(state$)\n  return Object.assign(state$, cache.get(state$)!, {\n    pipeState: (...operators: any[]) =>\n      enhanceState((originalPipeState as any)(...operators)),\n  })\n}\n", "import {\n  DefaultedStateObservable,\n  liftSuspense,\n  NoSubscribersError,\n  StateObservable,\n  StatePromise,\n  SUSPENSE,\n} from \"@rx-state/core\"\nimport { useRef, useState } from \"react\"\nimport useSyncExternalStore from \"./internal/useSyncExternalStore\"\nimport { useSubscription } from \"./Subscribe\"\n\ntype VoidCb = () => void\n\ninterface Ref<T> {\n  source$: StateObservable<T>\n  args: [(cb: VoidCb) => VoidCb, () => Exclude<T, SUSPENSE>]\n}\n\nexport const useStateObservable = <O>(\n  source$: StateObservable<O>,\n): Exclude<O, typeof SUSPENSE> => {\n  const subscription = useSubscription()\n  const [, setError] = useState()\n  const callbackRef = useRef<Ref<O>>()\n\n  if (!callbackRef.current) {\n    const getValue = (src: StateObservable<O>) => {\n      const result = src.getValue()\n      if (result instanceof StatePromise)\n        throw result.catch((e) => {\n          if (e instanceof NoSubscribersError) return e\n          throw e\n        })\n      return result as any\n    }\n\n    const gv: <T>() => Exclude<T, typeof SUSPENSE> = () => {\n      const src = callbackRef.current!.source$ as DefaultedStateObservable<O>\n      if (!src.getRefCount() && !src.getDefaultValue) {\n        if (!subscription) throw new Error(\"Missing Subscribe!\")\n        subscription(src)\n      }\n      return getValue(src)\n    }\n\n    callbackRef.current = {\n      source$: null as any,\n      args: [, gv] as any,\n    }\n  }\n\n  const ref = callbackRef.current\n  if (ref.source$ !== source$) {\n    ref.source$ = source$\n    ref.args[0] = (next: () => void) => {\n      const subscription = liftSuspense()(source$).subscribe({\n        next,\n        error: (e) => {\n          setError(() => {\n            throw e\n          })\n        },\n      })\n      return () => {\n        subscription.unsubscribe()\n      }\n    }\n  }\n\n  return useSyncExternalStore(...ref!.args)\n}\n", "export { useSyncExternalStore as default } from \"use-sync-external-store/shim/index.js\"\n", "import React, {\n  useState,\n  Suspense,\n  useEffect,\n  ReactNode,\n  useRef,\n  createContext,\n  useContext,\n} from \"react\"\nimport { Observable, Subscription } from \"rxjs\"\nimport { liftSuspense, StateObservable } from \"@rx-state/core\"\nimport { EMPTY_VALUE } from \"./internal/empty-value\"\n\nconst SubscriptionContext = createContext<\n  ((src: StateObservable<any>) => void) | null\n>(null)\nconst { Provider } = SubscriptionContext\nexport const useSubscription = () => useContext(SubscriptionContext)\n\nconst p = Promise.resolve()\nconst Throw = () => {\n  throw p\n}\n\n/**\n * A React Component that:\n * - collects the subscriptions of its children and it unsubscribes them when\n * the component unmounts.\n * - if a source$ property is used, then it ensures that the subscription to the\n * observable will exist before the children gets rendered, and it unsubscribes\n * from it when the component unmounts.\n *\n * If the fallback property is used, then the component will create a Suspense\n * boundary with the provided JSX Element, otherwise it will render null until\n * the subscription exists.\n *\n * @param [source$] (=undefined) - Source observable that the Component will\n * subscrib to before it renders its children.\n * @param [fallback] (=null) - JSX Element to be used by the Suspense boundary.\n *\n * @remarks This Component doesn't trigger any updates from the source$.\n */\nexport const Subscribe: React.FC<{\n  children?: React.ReactNode | undefined\n  source$?: Observable<any>\n  fallback?: NonNullable<ReactNode> | null\n}> = ({ source$, children, fallback }) => {\n  const subscriptionRef = useRef<{\n    s: Subscription\n    u: (source: StateObservable<any>) => void\n  }>()\n\n  if (!subscriptionRef.current) {\n    const s = new Subscription()\n    subscriptionRef.current = {\n      s,\n      u: (src) => {\n        let error = EMPTY_VALUE\n        let synchronous = true\n        s.add(\n          liftSuspense()(src).subscribe({\n            error: (e) => {\n              if (synchronous) {\n                // Can't setState of this component when another one is rendering.\n                error = e\n                return\n              }\n              setSubscribedSource(() => {\n                throw e\n              })\n            },\n          }),\n        )\n        synchronous = false\n        if (error !== EMPTY_VALUE) {\n          throw error\n        }\n      },\n    }\n  }\n\n  const [subscribedSource, setSubscribedSource] = useState<\n    Observable<any> | null | undefined\n  >(null)\n\n  if (subscribedSource !== null && subscribedSource !== source$) {\n    if (source$ === undefined) {\n      setSubscribedSource(source$)\n    } else {\n      try {\n        ;(source$ as any).getValue()\n        setSubscribedSource(source$)\n      } catch (e: any) {}\n    }\n  }\n\n  useEffect(() => {\n    setSubscribedSource(source$)\n    if (!source$) return\n\n    const subscription = liftSuspense()(source$).subscribe({\n      error: (e) =>\n        setSubscribedSource(() => {\n          throw e\n        }),\n    })\n    return () => {\n      subscription.unsubscribe()\n    }\n  }, [source$])\n\n  useEffect(() => {\n    return () => {\n      subscriptionRef.current?.s.unsubscribe()\n      subscriptionRef.current = undefined\n    }\n  }, [])\n\n  const actualChildren =\n    subscribedSource === source$ ? (\n      <Provider value={subscriptionRef.current!.u}>{children}</Provider>\n    ) : fallback === undefined ? null : (\n      <Throw />\n    )\n\n  return fallback === undefined ? (\n    actualChildren\n  ) : (\n    <Suspense fallback={fallback}>{actualChildren}</Suspense>\n  )\n}\n\n/**\n * Component that prevents its children from using the parent `Subscribe` boundary\n * to manage their subscriptions.\n */\nexport const RemoveSubscribe: React.FC<{\n  children?: React.ReactNode | undefined\n}> = ({ children }) => <Provider value={null}>{children}</Provider>\n"],
  "mappings": "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",
  "names": []
}
