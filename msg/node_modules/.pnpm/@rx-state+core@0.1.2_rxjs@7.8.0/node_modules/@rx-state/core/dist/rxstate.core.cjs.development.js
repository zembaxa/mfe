var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/index.ts
var src_exports = {};
__export(src_exports, {
  EmptyObservableError: () => EmptyObservableError,
  NoSubscribersError: () => NoSubscribersError,
  SUSPENSE: () => SUSPENSE,
  StatePromise: () => StatePromise,
  liftSuspense: () => liftSuspense,
  sinkSuspense: () => sinkSuspense,
  state: () => state2,
  withDefault: () => withDefault
});
module.exports = __toCommonJS(src_exports);

// src/SUSPENSE.ts
var SUSPENSE = Symbol("SUSPENSE");

// src/StatePromise.ts
var StatePromise = class extends Promise {
  constructor(cb) {
    super(cb);
  }
};

// src/errors.ts
var NoSubscribersError = class extends Error {
  constructor() {
    super();
    this.name = "NoSubscribersError";
  }
};
var EmptyObservableError = class extends Error {
  constructor() {
    super();
    this.name = "EmptyObservableError";
  }
};

// src/internal/empty-value.ts
var EMPTY_VALUE = {};

// src/state/stateFactory.ts
var import_rxjs2 = require("rxjs");

// src/internal/state-observable.ts
var import_rxjs = require("rxjs");
var StateObservable = class extends import_rxjs.Observable {
  constructor(source$, defaultValue, teardown = import_rxjs.noop) {
    super((subscriber) => {
      const subscriberWithoutComplete = new import_rxjs.Subscriber({
        next: subscriber.next.bind(subscriber),
        error: subscriber.error.bind(subscriber),
        complete: import_rxjs.noop
      });
      this.refCount++;
      let innerSub;
      subscriber.add(() => {
        var _a;
        this.refCount--;
        innerSub.unsubscribe();
        if (this.refCount === 0) {
          this.currentValue = EMPTY_VALUE;
          if (this.subscription) {
            this.subscription.unsubscribe();
          }
          teardown();
          (_a = this.subject) == null ? void 0 : _a.complete();
          this.subject = null;
          this.subscription = null;
          if (this.promise) {
            this.promise.rej(new NoSubscribersError());
            this.promise = null;
          }
        }
      });
      if (!this.subject) {
        this.subject = new import_rxjs.Subject();
        innerSub = this.subject.subscribe(subscriberWithoutComplete);
        this.subscription = null;
        this.subscription = new import_rxjs.Subscriber({
          next: (value) => {
            if (this.promise && value !== SUSPENSE) {
              this.promise.res(value);
              this.promise = null;
            }
            this.subject.next(this.currentValue = value);
          },
          error: (err) => {
            var _a;
            this.subscription = null;
            const subject = this.subject;
            this.subject = null;
            this.currentValue = EMPTY_VALUE;
            const rej = (_a = this.promise) == null ? void 0 : _a.rej;
            if (rej && err === SUSPENSE) {
              this.promise.rej = () => {
                rej(err);
              };
            }
            subject.error(err);
            if (rej && this.promise) {
              this.promise.rej = rej;
            }
          },
          complete: () => {
            this.subscription = null;
            if (this.promise) {
              this.promise.rej(new EmptyObservableError());
              this.promise = null;
            }
            if (this.currentValue !== EMPTY_VALUE)
              return this.subject.complete();
            if (defaultValue === EMPTY_VALUE) {
              const subject = this.subject;
              this.subject = null;
              return subject.error(new EmptyObservableError());
            }
            this.subject.next(this.currentValue = defaultValue);
            this.subject.complete();
          }
        });
        source$.subscribe(this.subscription);
        if (defaultValue !== EMPTY_VALUE && this.currentValue === EMPTY_VALUE) {
          this.subject.next(this.currentValue = defaultValue);
        }
      } else {
        innerSub = this.subject.subscribe(subscriberWithoutComplete);
        if (this.currentValue !== EMPTY_VALUE) {
          subscriber.next(this.currentValue);
        }
      }
    });
    this.defaultValue = defaultValue;
    __publicField(this, "subject", null);
    __publicField(this, "subscription", null);
    __publicField(this, "refCount", 0);
    __publicField(this, "currentValue", EMPTY_VALUE);
    __publicField(this, "promise", null);
    __publicField(this, "pipeState", (...ops) => {
      const result = super.pipe(...ops);
      return result instanceof StateObservable ? result : new StateObservable(result, EMPTY_VALUE);
    });
    __publicField(this, "getRefCount", () => {
      return this.refCount;
    });
    __publicField(this, "getValue", () => {
      if (this.promise)
        return this.promise.p;
      if (this.currentValue !== EMPTY_VALUE && this.currentValue !== SUSPENSE)
        return this.currentValue;
      if (this.defaultValue !== EMPTY_VALUE)
        return this.defaultValue;
      if (this.refCount === 0)
        throw new NoSubscribersError();
      const promise = new StatePromise((res, rej) => {
        this.promise = { res, rej, p: null };
      });
      this.promise.p = promise;
      return promise;
    });
    __publicField(this, "getDefaultValue", () => {
      return this.defaultValue;
    });
    if (defaultValue === EMPTY_VALUE) {
      delete this.getDefaultValue;
    }
  }
};

// src/state/stateFactory.ts
function cloneProps(internal, external) {
  external.getValue = internal.getValue;
  external.getRefCount = internal.getRefCount;
  external.pipeState = internal.pipeState;
  if (internal.getDefaultValue) {
    ;
    external.getDefaultValue = internal.getDefaultValue;
  }
}
function connectFactoryObservable(getObservable, defaultValue) {
  const cache = new NestedMap();
  const getDefaultValue = typeof defaultValue === "function" ? defaultValue : () => defaultValue;
  const getSharedObservables$ = (input) => {
    for (let i = input.length - 1; input[i] === void 0 && i > -1; i--) {
      input.splice(-1);
    }
    const keys = [input.length, ...input];
    const cachedVal = cache.get(keys);
    if (cachedVal !== void 0) {
      return cachedVal;
    }
    const sharedObservable$ = new StateObservable(getObservable(...input), getDefaultValue(...input), () => {
      cache.delete(keys);
    });
    const publicShared$ = new import_rxjs2.Observable((subscriber) => {
      const inCache = cache.get(keys);
      let source$ = sharedObservable$;
      if (!inCache) {
        cache.set(keys, result);
      } else if (inCache !== publicShared$) {
        source$ = inCache;
        cloneProps(source$, publicShared$);
      }
      return source$.subscribe(subscriber);
    });
    cloneProps(sharedObservable$, publicShared$);
    const result = publicShared$;
    cache.set(keys, result);
    return result;
  };
  return (...input) => getSharedObservables$(input);
}
var NestedMap = class {
  constructor() {
    __publicField(this, "root");
    this.root = /* @__PURE__ */ new Map();
  }
  get(keys) {
    let current = this.root;
    for (let i = 0; i < keys.length; i++) {
      current = current.get(keys[i]);
      if (!current)
        return void 0;
    }
    return current;
  }
  set(keys, value) {
    let current = this.root;
    let i;
    for (i = 0; i < keys.length - 1; i++) {
      let nextCurrent = current.get(keys[i]);
      if (!nextCurrent) {
        nextCurrent = /* @__PURE__ */ new Map();
        current.set(keys[i], nextCurrent);
      }
      current = nextCurrent;
    }
    current.set(keys[i], value);
  }
  delete(keys) {
    const maps = [this.root];
    let current = this.root;
    for (let i = 0; i < keys.length - 1; i++) {
      maps.push(current = current.get(keys[i]));
    }
    let mapIdx = maps.length - 1;
    maps[mapIdx].delete(keys[mapIdx]);
    while (--mapIdx > -1 && maps[mapIdx].get(keys[mapIdx]).size === 0) {
      maps[mapIdx].delete(keys[mapIdx]);
    }
  }
};

// src/state/stateSingle.ts
function state(observable, defaultValue) {
  return new StateObservable(observable, defaultValue);
}

// src/state/index.ts
var state2 = (...args) => (typeof args[0] === "function" ? connectFactoryObservable : state)(args[0], args.length > 1 ? args[1] : EMPTY_VALUE);

// src/withDefault.ts
var withDefault = (defaultValue) => (source$) => state2(source$, defaultValue);

// src/effects/sinkSuspense.ts
var import_rxjs3 = require("rxjs");
var sinkSuspense = () => {
  return (source$) => {
    let waiting = null;
    return new import_rxjs3.Observable((observer) => {
      if (waiting) {
        waiting.inner = observer;
        const outter2 = waiting;
        return () => {
          if (outter2.inner === observer)
            outter2.unsubscribe();
        };
      }
      let outter = new import_rxjs3.Subscriber({
        next(value) {
          if (value === SUSPENSE) {
            waiting = outter;
            outter.inner.error(value);
            waiting = null;
            if (outter.inner === observer) {
              outter.unsubscribe();
            }
          } else {
            outter.inner.next(value);
          }
        },
        error(e) {
          outter.inner.error(e);
        },
        complete() {
          outter.inner.complete();
        }
      });
      outter.inner = observer;
      source$.subscribe(outter);
      return () => {
        if (outter.inner === observer)
          outter.unsubscribe();
      };
    });
  };
};

// src/effects/liftSuspense.ts
var import_rxjs4 = require("rxjs");
var liftSuspense = () => {
  return (source$) => {
    return new import_rxjs4.Observable((observer) => {
      let subscriber;
      const setSubscriber = () => {
        subscriber = new import_rxjs4.Subscriber({
          next(v) {
            observer.next(v);
          },
          error(e) {
            if (e === SUSPENSE) {
              observer.next(e);
              setSubscriber();
            } else
              observer.error(e);
          },
          complete() {
            observer.complete();
          }
        });
        source$.subscribe(subscriber);
      };
      setSubscriber();
      return () => {
        subscriber.unsubscribe();
      };
    });
  };
};
//# sourceMappingURL=rxstate.core.cjs.development.js.map
